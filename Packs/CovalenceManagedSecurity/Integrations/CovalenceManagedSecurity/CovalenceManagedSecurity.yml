category: Endpoint
commonfields:
  id: Covalence Managed Security
  version: -1
configuration:
- display: Credentials
  name: credentials
  required: true
  type: 9
- display: Use system proxy settings
  name: proxy
  type: 8
  required: false
- additionalinfo: When fetching incidents for the first time, this parameter specifies in days how far the integration looks for incidents. For instance if set to "2", it will pull all alerts in Covalence for the last 2 days and will create corresponding incidents.
  defaultvalue: '1'
  display: First run time range
  name: first_run_time_range
  type: 0
  required: false
- display: Incident type
  name: incidentType
  type: 13
  required: false
- display: Fetch incidents
  name: isFetch
  type: 8
  required: false
- defaultvalue: 7 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: first_fetch
  type: 0
  required: false
- additionalinfo: the maximum number of incidents to fetch
  defaultvalue: '50'
  display: Fetch Limit
  name: max_fetch
  type: 0
  required: false
description: Triggers by triaged alerts from endpoint, cloud, and network security monitoring. Contains event details and easy-to-follow mitigation steps.
display: Covalence Managed Security (Partner Contribution)
name: Covalence Managed Security
script:
  commands:
  - arguments:
    - description: if details=true, will return the complete response from Covalence API.
      name: details
      default: false
      isArray: false
      required: false
      secret: false
    - description: "Portal query, for example: \"resolution=Unresolved&type=Recommendation\"\nAvailable Keys to filter on:\n- id; eg: \"id=<ARO_id>\n- status; eg: \"status=In Triage\" or \"status=Open\" or \"status=Closed\"\n- resolution; eg: \"resolution=Unresolved\" or \"resolution=Resolved\" or \"resolution=Help Requested\" or \"resolution=Dismissed\"\n- type; eg: \"type=Action\" or \"type=Recommendation\" or \"type=Observation\"\n- org; eg: \"org=<organization_name>\"\n- since; eg: \"since=2021-01-31 14:00:00\"\n- until; eg: \"until=2021-01-31 14:00:00\"."
      name: query
      required: true
      default: false
      isArray: false
      secret: false
    description: Query FES Portal for ARO.
    name: cov-mgsec-get-aro
    outputs:
    - contextPath: FESPortal.Aro.ID
      description: ID.
      type: String
    - contextPath: FESPortal.Aro.alert_key
      description: Alert_key.
      type: String
    - contextPath: FESPortal.Aro.analyst_notes
      description: Analyst_notes.
      type: String
    - contextPath: FESPortal.Aro.count
      description: Count.
      type: Number
    - contextPath: FESPortal.Aro.creation_time
      description: Creation_time.
      type: Date
    - contextPath: FESPortal.Aro.details
      description: Details.
      type: String
    - contextPath: FESPortal.Aro.details_markdown
      description: Details_markdown.
      type: String
    - contextPath: FESPortal.Aro.display_url
      description: Display_url.
      type: String
    - contextPath: FESPortal.Aro.external_bug_id
      description: External_bug_id.
      type: String
    - contextPath: FESPortal.Aro.last_updated_time
      description: Last_updated_time.
      type: Date
    - contextPath: FESPortal.Aro.notes
      description: Notes.
      type: String
    - contextPath: FESPortal.Aro.organization.ID
      description: ID.
      type: String
    - contextPath: FESPortal.Aro.organization.email
      description: Email.
      type: String
    - contextPath: FESPortal.Aro.organization.name
      description: Name.
      type: String
    - contextPath: FESPortal.Aro.resolution
      description: Resolution.
      type: String
    - contextPath: FESPortal.Aro.serial_id
      description: Serial_id.
      type: String
    - contextPath: FESPortal.Aro.severity
      description: Severity.
      type: String
    - contextPath: FESPortal.Aro.status
      description: Status.
      type: String
    - contextPath: FESPortal.Aro.steps.ID
      description: ID.
      type: String
    - contextPath: FESPortal.Aro.steps.completed
      description: Completed.
      type: Boolean
    - contextPath: FESPortal.Aro.steps.label
      description: Label.
      type: String
    - contextPath: FESPortal.Aro.steps.last_updated_time
      description: Last_updated_time.
      type: Date
    - contextPath: FESPortal.Aro.template_id
      description: Template_id.
      type: String
    - contextPath: FESPortal.Aro.title
      description: Title.
      type: String
    - contextPath: FESPortal.Aro.triage_id
      description: Triage_id.
      type: String
    - contextPath: FESPortal.Aro.type
      description: Type.
      type: String
    deprecated: false
    execution: false
  - description: List organizations.
    name: cov-mgsec-list-org
    outputs:
    - contextPath: FESPortal.Org.ID
      description: ID.
      type: String
    - contextPath: FESPortal.Org.email
      description: Email.
      type: String
    - contextPath: FESPortal.Org.email_aro_details
      description: Email_aro_details.
      type: Boolean
    - contextPath: FESPortal.Org.name
      description: Name.
      type: String
    deprecated: false
    execution: false
  - description: Transition an ARO.
    name: cov-mgsec-transition-aro
    arguments:
    - name: aro_id
      required: true
      default: false
      isArray: false
      secret: false
      description: This ARO ID to transition.
    - name: resolution
      required: true
      default: false
      isArray: false
      secret: false
      description: 'Resolution to transition the ARO to.  Options include: Unresolved, Help Requested, Resolved, or Dismissed.'
    - name: comment
      required: false
      default: false
      isArray: false
      secret: false
      description: Optional comment to leave on the ARO.
    - name: is_comment_sensitive
      required: false
      default: false
      isArray: false
      secret: false
      description: Optionally mark the comment as sensitive.
    outputs:
    - contextPath: FESPortal.Aro.ID
      description: ID.
      type: String
    - contextPath: FESPortal.Aro.alert_key
      description: Alert_key.
      type: String
    - contextPath: FESPortal.Aro.analyst_notes
      description: Analyst_notes.
      type: String
    - contextPath: FESPortal.Aro.count
      description: Count.
      type: Number
    - contextPath: FESPortal.Aro.creation_time
      description: Creation_time.
      type: Date
    - contextPath: FESPortal.Aro.details
      description: Details.
      type: String
    - contextPath: FESPortal.Aro.details_markdown
      description: Details_markdown.
      type: String
    - contextPath: FESPortal.Aro.display_url
      description: Display_url.
      type: String
    - contextPath: FESPortal.Aro.external_bug_id
      description: External_bug_id.
      type: String
    - contextPath: FESPortal.Aro.last_updated_time
      description: Last_updated_time.
      type: Date
    - contextPath: FESPortal.Aro.notes
      description: Notes.
      type: String
    - contextPath: FESPortal.Aro.organization.ID
      description: ID.
      type: String
    - contextPath: FESPortal.Aro.organization.email
      description: Email.
      type: String
    - contextPath: FESPortal.Aro.organization.name
      description: Name.
      type: String
    - contextPath: FESPortal.Aro.resolution
      description: Resolution.
      type: String
    - contextPath: FESPortal.Aro.serial_id
      description: Serial_id.
      type: String
    - contextPath: FESPortal.Aro.severity
      description: Severity.
      type: String
    - contextPath: FESPortal.Aro.status
      description: Status.
      type: String
    - contextPath: FESPortal.Aro.steps.ID
      description: ID.
      type: String
    - contextPath: FESPortal.Aro.steps.completed
      description: Completed.
      type: Boolean
    - contextPath: FESPortal.Aro.steps.label
      description: Label.
      type: String
    - contextPath: FESPortal.Aro.steps.last_updated_time
      description: Last_updated_time.
      type: Date
    - contextPath: FESPortal.Aro.template_id
      description: Template_id.
      type: String
    - contextPath: FESPortal.Aro.title
      description: Title.
      type: String
    - contextPath: FESPortal.Aro.triage_id
      description: Triage_id.
      type: String
    - contextPath: FESPortal.Aro.type
      description: Type.
      type: String
  dockerimage: demisto/python3:3.10.13.80593
  isfetch: true
  runonce: false
  script: >
    register_module_line('Covalence Managed Security', 'start', __line__())

    ### pack version: 1.1.10



    import os

    import requests

    import traceback

    import json

    from datetime import datetime, timedelta

    from requests import HTTPError


    DATE_FORMAT = '%Y-%m-%d %H:%M:%S'

    EMAIL = demisto.params().get('credentials')['identifier']

    API_KEY = demisto.params().get('credentials')['password']

    FIRST_RUN_TIME_RANGE = int(demisto.params().get('first_run_time_range').strip())

    PROXY = demisto.params().get('proxy')

    if not demisto.params().get('proxy', False):
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']


    class Portal():
        def __init__(self, bearer=None, portal_url="https://services.fieldeffect.net/v1", provider=None, verbose=False):
            self.auth = None
            self.portal_url = portal_url
            self.verbose = verbose
            self.provider_name = provider
            if bearer == "gan ceann":
                self.scheme = self.AuthScheme.FES
                # Headless login for those cursed with a GUI
            elif bearer:
                self.scheme = self.AuthScheme.BEARER
                self.auth = {"token": bearer, "expires": datetime.now() + timedelta(days=10 * 365), "refresh": None}
                self.provider_id = self.get_provider_id()
            else:
                raise ValueError('Bearer is missing')

        class AuthScheme(object):
            FES = 'FieldEffectAuth'
            BEARER = 'Bearer'
            KEY = 'FieldEffectKey'

        def try_saved_token(self, token):
            # Return True if this token works, also save this token as the token
            # Return False if this token doesn't work and user will need to auth
            try:
                self.auth = token
                if self.provider_name:
                    self.provider_id = self.find_provider(self.provider_name)
                else:
                    self.provider_id = self.get_provider_id()
                return True

            except requests.exceptions.HTTPError:
                self.auth = None
                return False

        def get(self, uri, query=None, headers=None, remove_subdomain=False, **kwargs):
            return self._request(uri, method='GET', query=query, headers=headers, remove_subdomain=remove_subdomain,
                                 **kwargs)

        def post(self, uri, query=None, headers=None, remove_subdomain=False, **kwargs):
            return self._request(uri, method='POST', query=query, headers=headers, remove_subdomain=remove_subdomain, **kwargs)

        def _request(self, uri, method='GET', query=None, json=None, data=None, files=None, headers=None,
                     remove_subdomain=False, **kwargs):
            all_headers = {
                'Content-Type': 'application/json'
            } if json is not None else {}

            if headers is not None:
                all_headers.update(headers)
            if self.auth:
                auth = '{} {}'.format(self.scheme, self.auth['token'])
                all_headers.update({'Authorization': auth})

            url = '{}/{}'.format(self.portal_url, uri if len(kwargs) == 0 else uri.format(**kwargs))
            if remove_subdomain:
                url = url.replace('services.', '')

            if self.verbose:
                sys.stdout.write('{} {} '.format(method, url))

            if method == 'GET':
                r = requests.get(url, headers=all_headers, params=query)
            elif method == 'POST':
                r = requests.post(url, headers=all_headers, json=json, data=data, params=query, files=files)
            elif method == 'PUT':
                r = requests.put(url, headers=all_headers, json=json, data=data, params=query, files=files)
            elif method == 'DELETE':
                r = requests.delete(url, headers=all_headers, params=query)
            else:
                raise AssertionError('Unsupported HTTP method: {}'.format(method))

            if self.verbose:
                sys.stdout.write(str(r.status_code) + '\n')
            if r.status_code >= 400:
                raise HTTPError(r.text)
            return r

        def get_provider_id(self):
            r = self.get('my_providers', auth=self.auth)
            if not r.json():
                raise ValueError(f'Account {EMAIL} is not part of any provider')
            return r.json()[0]['ID']

        def find_provider(self, provider):
            r = self.get('providers', auth=self.auth)
            providers = r.json()
            for prov in providers:
                if provider == prov["name"] or provider == prov["ID"]:
                    return prov["ID"]
            return None

        def get_organizations(self):
            r = self.get('my_providers/{id}/organizations', auth=self.auth, id=self.provider_id)
            return r.json()

        def find_organizations(self, org):
            r = self.get('my_providers/{id}/organizations', auth=self.auth, id=self.provider_id)
            orgs = r.json()
            matches = []
            for o in orgs:
                if org.lower() in o["name"].lower():
                    matches.append(o)
            return matches

        def get_aros(self, **kwargs):
            aros = []
            if "query" not in kwargs:
                kwargs["query"] = {}
            kwargs["query"]["limit"] = 500
            r = self.get('providers/{id}/aros', auth=self.auth, id=self.provider_id, **kwargs).json()
            aros.extend(r["items"])
            while len(aros) < r["total"]:
                kwargs["query"]["page"] = r["page"] + 1
                r = self.get('providers/{id}/aros', auth=self.auth, id=self.provider_id, **kwargs).json()
                aros.extend(r["items"])
            return aros

        def get_active_response_profile(self, org_id):
            r = self.get('my_organizations/{org_id}', auth=self.auth, org_id=org_id)
            org_details = r.json()
            return org_details.get('active_response_profile', None)

        def transition_aro(self, aro_id, resolution, comment="", is_comment_sensitive=False):
            request = {
                "status": "Open",
                "resolution": resolution
            }
            if comment:
                request["comment"] = {"text": comment, "sensitive": is_comment_sensitive}

            r = self.post("aros/{aro_id}/transition", aro_id=aro_id, json=request)
            return r.json()


    ''' Commands '''



    def portal_check():
        '''
        Poking to the portal to make sure it's up
        '''
        try:
            Portal(bearer=API_KEY)
            return True
        except Exception:
            demisto.debug(traceback.format_exc())
            return False


    def fetch_incidents(last_run, first_run_time_range):
        last_fetch = last_run.get('last_fetch', None)
        aro_time_max = datetime.utcnow() - timedelta(seconds=1)

        if last_fetch is None:
            aro_time_min = aro_time_max - timedelta(days=first_run_time_range)
        else:
            aro_time_min = dateparser.parse(last_fetch)  # type: ignore
        assert aro_time_min is not None

        p = Portal(bearer=API_KEY)
        query = {'resolution': 'Unresolved',
                 'since': aro_time_min.strftime(DATE_FORMAT),
                 'until': aro_time_max.strftime(DATE_FORMAT)}
        aros = p.get_aros(query=query)

        incidents = []

        # AROs are ordered by most recent ARO
        # it's required to traverse aros in chronological order (so last element first)
        # to avoid duplicating incidents
        for a in reversed(aros):
            created_time = dateparser.parse(a['creation_time'])
            assert created_time is not None, f'could not parse {a["creation_time"]}'
            if created_time != last_fetch:
                created_time_str = created_time.strftime(DATE_FORMAT)

                if a.get('organization', None):
                    org_name = a['organization'].get('name', 'No org name')
                    org_id = a['organization'].get('ID', None)
                else:
                    org_name = 'No org name'
                    org_id = None

                aro_type = a.get('type', 'No ARO type')

                aro_title = a.get('title', 'No title')

                incident: Dict[str, Any] = {
                    'name': f'''[{org_name}] [{aro_type}] {aro_title}''',
                    'occured': created_time_str,
                    'rawJSON': json.dumps(a)
                }
                if a.get('severity', None):
                    # XSOAR mapping
                    # Unknown: 0
                    # Informational: 0.5
                    # Low: 1
                    # Medium: 2
                    # High: 3
                    # Critical: 4
                    severity_from_portal = a['severity']
                    if severity_from_portal == 'Informational':
                        incident['severity'] = 0.5
                    elif severity_from_portal == 'Warning':
                        incident['severity'] = 1
                    elif severity_from_portal == 'Low':
                        incident['severity'] = 1
                    elif severity_from_portal == 'Medium':
                        incident['severity'] = 2
                    elif severity_from_portal == 'High':
                        incident['severity'] = 3
                    elif severity_from_portal == 'Critical':
                        incident['severity'] = 4
                else:
                    incident['severity'] = 0
                if a.get('details', None):
                    incident['details'] = a['details']
                    if a.get('steps', None) and len(a['steps']) > 0:
                        incident['details'] += '\n\nMitigation Steps\n'
                        for step in a['steps']:
                            incident['details'] += f'''- {step['label']}\n'''
                    if org_id:
                        active_response_profile = p.get_active_response_profile(org_id)
                        if active_response_profile:
                            policy = active_response_profile.get('response_policy')
                            options = active_response_profile.get('options')
                            incident['details'] += '\nActive Response Profile\n'
                            incident['details'] += f'''- Response policy: {policy}\n'''
                            incident['details'] += f'''- Exclusions/ Modifications: {options}\n'''

                incidents.append(incident)

        next_run = {'last_fetch': aro_time_max.strftime(DATE_FORMAT)}

        return next_run, incidents


    def get_aros():
        p = Portal(bearer=API_KEY)

        q = demisto.args().get('query', None)

        if q:
            query = {}  # pragma: no cover
            for param in q.split('&'):
                key = param.split('=')[0]
                value = param.split('=')[1]
                query[key] = value

                if 'org' in query:
                    org = p.find_organizations(query['org'])
                    if not org:
                        raise ValueError(f'Unknown organization named {query["org"]}')
                    del query['org']
                    query['organization_id'] = org[0]['ID']
            aros = p.get_aros(query=query)
        else:
            aros = p.get_aros()

        details = argToBoolean(demisto.args().get('details', 'false'))
        keys = ['title',
                'organization',
                'resolution',
                'severity',
                'status',
                'type']

        if not details:
            filtered_r = []
            # returning only data in keys
            for aro in aros:
                a = {k: aro[k] for k in keys}
                filtered_r.append(a)
            return filtered_r
        else:
            return aros


    def list_organizations():
        p = Portal(bearer=API_KEY)

        return p.get_organizations()


    def transition_aro_command():
        p = Portal(bearer=API_KEY)
        args = demisto.args()
        return p.transition_aro(**args)


    def main():
        demisto.info(f'{demisto.command()} is called')
        try:
            if demisto.command() == 'test-module':
                if portal_check():
                    return_results('ok')
                else:
                    return_results('nok')

            elif demisto.command() == 'fetch-incidents':
                next_run, incidents = fetch_incidents(
                    last_run=demisto.getLastRun(),
                    first_run_time_range=FIRST_RUN_TIME_RANGE)

                demisto.setLastRun(next_run)
                demisto.incidents(incidents)

            elif demisto.command() == 'cov-mgsec-get-aro':
                r = get_aros()
                if r:
                    readable_output = tableToMarkdown('AROs', r, removeNull=True, headerTransform=string_to_table_header)
                else:
                    readable_output = 'No AROs found'

                results = CommandResults(
                    outputs_prefix='FESPortal.ARO',
                    outputs_key_field='ID',
                    outputs=r,
                    readable_output=readable_output
                )
                return_results(results)
            elif demisto.command() == 'cov-mgsec-list-org':
                r = list_organizations()
                if r:
                    readable_output = tableToMarkdown('Organizations', r, removeNull=True,
                                                      headerTransform=string_to_table_header)
                else:
                    readable_output = 'No organizations found'

                results = CommandResults(
                    outputs_prefix='FESPortal.Org',
                    outputs_key_field='ID',
                    outputs=r,
                    readable_output=readable_output
                )
                return_results(results)
            elif demisto.command() == 'cov-mgsec-transition-aro':
                r = transition_aro_command()
                if r:
                    readable_output = tableToMarkdown('ARO', r, removeNull=True,
                                                      headerTransform=string_to_table_header)
                else:
                    readable_output = 'Error transitioning ARO.'

                results = CommandResults(
                    outputs_prefix='FESPortal.Org',
                    outputs_key_field='ID',
                    outputs=r,
                    readable_output=readable_output
                )
                return_results(results)
            else:
                msg = f'Unknown command {demisto.command()}'
                demisto.error(msg)
        except Exception as e:
            demisto.error(traceback.format_exc())
            return_error(f'Failed to execute {demisto.command()} command. Error: {str(e)}. {traceback.format_exc()}')


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('Covalence Managed Security', 'end', __line__())
  subtype: python3
  type: python
  feed: false
  longRunning: false
  longRunningPort: false
  nativeimage:
  - '8.3'
  - '8.4'
tests:
- No tests (auto formatted)
fromversion: 5.0.0
beta: false
image: data:image/png;base64,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
detaileddescription: "### Partner Contributed Integration\n#### Integration Author: Field Effect Security\nSupport and maintenance for this integration are provided by the author. Please use the following contact details:\n- **Email**: [support@fieldeffect.com](mailto:support@fieldeffect.com)\n- **URL**: [https://fieldeffect.com/products/covalence-cyber-security/](https://fieldeffect.com/products/covalence-cyber-security/)\n***\n## FES-Portal\n\n**The account used to leverage the Portal API through this integration must be part of a provider on the Portal side.**\n\n- credentials\n   - Your email to connect to the Field Effect Security Portal\n- password\n   - API key to access Field Effect Security Portal, generated from Field Effect Portal\n\n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/covalence-managed-security)"
